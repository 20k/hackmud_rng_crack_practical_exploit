#include <iostream>
#include <z3++.h>
#include <z3.h>
#include <vector>
#include <math.h>
#include <stdint.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <map>
#include <SFML/Graphics.hpp>

using namespace z3;
using namespace std;

/*def sym_xs128p(slvr, sym_state0, sym_state1, generated):
    s1 = sym_state0
    s0 = sym_state1
    s1 ^= (s1 << 23)
    s1 ^= LShR(s1, 17)
    s1 ^= s0
    s1 ^= LShR(s0, 26)
    sym_state0 = sym_state1
    sym_state1 = s1
    calc = (sym_state0 + sym_state1)

    condition = Bool('c%d' % int(generated * random.random()))

    impl = Implies(condition, (calc & 0xFFFFFFFFFFFFF) == int(generated))

    slvr.add(impl)
    return sym_state0, sym_state1, [condition]*/


/*
    dubs = [0.71818029236637937, 0.13145321474034222, 0.22632317820137171]

    print dubs

    # from the doubles, generate known piece of the original uint64
    generated = []
    for idx in xrange(len(dubs)):
        recovered = struct.unpack('<Q', struct.pack('d', dubs[idx] + 1))[0] & 0xFFFFFFFFFFFFF
        generated.append(recovered)

    # setup symbolic state for xorshift128+
    ostate0, ostate1 = BitVecs('ostate0 ostate1', 64)
    sym_state0 = ostate0
    sym_state1 = ostate1
    slvr = Solver()
    conditions = []

    # run symbolic xorshift128+ algorithm for three iterations
    # using the recovered numbers as constraints
    for ea in xrange(len(dubs)):
        sym_state0, sym_state1, ret_conditions = sym_xs128p(slvr, sym_state0, sym_state1, generated[ea])
        conditions += ret_conditions

    print "built_conditions"

    if slvr.check(conditions) == sat:
        # get a solved state
        m = slvr.model()
        state0 = m[ostate0].as_long()
        state1 = m[ostate1].as_long()*/

template<typename T>
std::string to_string_hex(T v)
{
    std::stringstream stream;
    stream << std::hex << v;
    std::string result( stream.str() );

    return result;
}

template<typename T>
std::string to_string_max_precision(T v)
{
    std::stringstream stream;
    stream.precision(17);

    stream << v;

    //stream << std::hex << v;
    std::string result( stream.str() );

    return result;
}

void split(const string &s, char delim, vector<string> &elems) {
    stringstream ss;
    ss.str(s);
    string item;
    while (getline(ss, item, delim)) {
        elems.push_back(item);
    }
}

vector<string> split(const string &s, char delim) {
    vector<string> elems;
    split(s, delim, elems);
    return elems;
}


double chrome(uint64_t v)
{
    uint64_t up = ((v & ((1ull << 52) - 1)) | 0x3FF0000000000000);

    return (*(double*)&up) -  1.0;
}

uint64_t iv_chrome(double v)
{
    uint64_t ret;

    double vn = v + 1.0;

    ret = *(uint64_t*)&vn;

    ///52 bits
    ret = ret & 0xFFFFFFFFFFFFF;

    return ret;
}

uint64_t state0 = 134125447415289812;
uint64_t state1 = 182415234512781923;
uint64_t xorshift128plus() {
    uint64_t s1 = state0;
    uint64_t s0 = state1;
    state0 = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >> 17;
    s1 ^= s0;
    s1 ^= s0 >> 26;
    state1 = s1;
    return state0 + state1;
}

void sym_xs128p(context& c, expr& sym_0, expr& sym_1, expr& sout0, expr& sout1, solver& s, const expr& t23, const expr& t17, const expr& t26, const expr& val, uint64_t rval, const expr& cpc)
{
    auto s1 = sym_0;
    auto s0 = sym_1;

    ///s1 ^= s1 << 23;
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvshl(s1.ctx(), s1, t23));
    ///s1 ^= s1 >> 17
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvlshr(s1.ctx(), s1, t17));

    ///s1 ^= s0
    s1 = s1 ^ s0;

    ///s1 ^= s0 >> 26
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvlshr( s1.ctx(), s0, t26));

    sout0 = s0;
    sout1 = s1;

    expr calc = s0 + s1;

    //std::cout << "val " << val << std::endl;

    s.add((calc & cpc) == val);
}

void sym_xs128p_sim(context& c, expr& sym_0, expr& sym_1, expr& sout0, expr& sout1, solver& s, const expr& t23, const expr& t17, const expr& t26, const expr& val, uint64_t rval, const expr& cpc)
{
    auto s1 = sym_0;
    auto s0 = sym_1;

    ///s1 ^= s1 << 23;
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvshl(s1.ctx(), s1, t23));
    ///s1 ^= s1 >> 17
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvlshr(s1.ctx(), s1, t17));

    ///s1 ^= s0
    s1 = s1 ^ s0;

    ///s1 ^= s0 >> 26
    s1 = s1 ^ to_expr(s1.ctx(), Z3_mk_bvlshr( s1.ctx(), s0, t26));

    sout0 = s0;
    sout1 = s1;
}
///Ok. I should be able to theorum solve if two states are compatible

void test()
{
    std::cout << "eval example 1\n";
    context c;
    expr x = c.int_const("x");
    expr y = c.int_const("y");
    solver s(c);

    /* assert x < y */
    s.add(x < y);
    /* assert x > 2 */
    s.add(x > 2);

    std::cout << s.check() << "\n";

    model m = s.get_model();
    std::cout << "Model:\n" << m << "\n";
    std::cout << "x+y = " << m.eval(x+y) << "\n";
}


void test(double d)
{

}

int main()
{
    //test();

    //double dubs[] = {0.71818029236637937, 0.13145321474034222, 0.22632317820137171};

    //.39011942274229460814,0.54714196159077843618,0.86852546499401772628,0.13327812370798475250

    ///old confirmed to work
    //double dubs[] = {0.13327812370798475250, 0.86852546499401772628, 0.54714196159077843618};

    ///first "0.36086276216304247200, 0.16175621775668935776, 0.40025633058521936647, 0.52204290322396551538, 0.01685704548347843890, "
    ///second "0.95824843880028787169, 0.14979908670577679608, 0.63689794533182064740, 0.78247552460479963266, 0.18456434157936185692, "


    //double dubs[] = {0.01685704548347843890, 0.52204290322396551538, 0.40025633058521936647};

    //double check_array[] = {0.16175621775668935776, 0.36086276216304247200};

    //double dubs[] = {0.18456434157936185692, 0.78247552460479963266, 0.63689794533182064740};

    ///FIRST

    //0.99296038142003739679, 0.67136690702246015761, 0.69287991623370315253, 0.65795407859757215618, 0.07913877046405426441,

    size_t found_pos = -1;

    std::string search_task = "JAMES_EZ_TASK:";

    // Save text in a string class instance
    std::string text;

    HANDLE hand = GetCurrentProcess();

    BOOL success = SetPriorityClass(hand, HIGH_PRIORITY_CLASS);

    std::cout << success << std::endl;

    int tick = 0;

    while(1)
    {
        if(!OpenClipboard(NULL))
        {
            continue;
        }

        HANDLE hData = GetClipboardData(CF_TEXT);

        if (hData == nullptr)
        {
            CloseClipboard();
            continue;
        }

        // Lock the handle to get the actual text pointer
        char * pszText = static_cast<char*>( GlobalLock(hData) );

        if (pszText == nullptr)
            return 2;

        std::string ntext(pszText);

        text = ntext;

        //std::cout << text << std::endl;

        // Release the lock
        GlobalUnlock( hData );

        found_pos = text.find(search_task);

        if(found_pos != std::string::npos)
        {
            text = text.substr(found_pos + search_task.size());

            std::vector<std::string> post_split = split(text, ' ');

            if(tick == 0)
            {
                EmptyClipboard();

                CloseClipboard();

                tick++;
                continue;
            }

            if(post_split.size() >= 4)
            {
                EmptyClipboard();

                CloseClipboard();

                break;
            }
        }

        CloseClipboard();

        tick++;

        Sleep(4);
    }

    std::cout << text << std::endl;

    std::vector<std::string> post_split = split(text, ' ');

    //double dubs[] = {0.07913877046405426441, 0.65795407859757215618, 0.69287991623370315253};


    //double check_array[] = {0.14979908670577679608, 0.95824843880028787169};

    ///stranger danger
    ////wait. these were produced earlier right?
    //double predict_array[] = {0.18456434157936185692};

    //double predict_array[] = {0.36086276216304247200};


    double dubs[3];

    dubs[2] = atof(post_split[0].c_str());
    dubs[1] = atof(post_split[1].c_str());
    dubs[0] = atof(post_split[2].c_str());


    int ndubs = sizeof(dubs) / sizeof(double);

    config cfg;

    z3::context c(cfg);

    expr s0 = c.bv_const("ostate0", 64);
    expr s1 = c.bv_const("ostate1", 64);

    auto s0b = s0;
    auto s1b = s1;

    auto t23 = c.bv_val(23, 64);
    auto t17 = c.bv_val(17, 64);
    auto t26 = c.bv_val(26, 64);

    uint64_t cp = 0xFFFFFFFFFFFFF;

    expr cpc = c.bv_val((unsigned long long)cp, 64);

    std::vector<uint64_t> converted;

    for(int i=0; i<ndubs; i++)
    {
        converted.push_back(iv_chrome(dubs[i]));

        //printf("%f\n", chrome(converted.back()));
    }

    //printf("%i nd\n", ndubs);

    std::vector<expr> cond;

    solver s(c);

    for(int i=0; i<ndubs; i++)
    {
        auto e2 = c.bv_val((unsigned long long)converted[i], 64);

        if(i % 2 == 1)
            sym_xs128p(c, s0b, s1b, s0, s1, s, t23, t17, t26, e2, converted[i], cpc);
        else
            sym_xs128p(c, s0, s1, s0b, s1b, s, t23, t17, t26, e2, converted[i], cpc);


        //std::cout << converted[i] << std::endl;
    }

    /*auto e2 = c.bv_val((unsigned long long)converted[0], 64);

    sym_xs128p_sim(c, s0b, s1b, s0, s1, s, t23, t17, t26, e2, converted[0], cpc);

    std::cout << s0.simplify() << std::endl;
    std::cout << s1.simplify() << std::endl;

    sym_xs128p(c, s0b, s1b, s0, s1, s, t23, t17, t26, e2, converted[0], cpc);

    std::cout << s0.simplify() << std::endl;
    std::cout << s1.simplify() << std::endl;

    return 0;*/


    check_result res = s.check();

    //std::cout << s << std::endl;

    if(res == check_result::sat)
    {
        //printf("yay\n");

        model m = s.get_model();

        func_decl d0 = m.get_const_decl(0);
        func_decl d1 = m.get_const_decl(1);

        expr e1 = m.get_const_interp(d0);
        expr e2 = m.get_const_interp(d1);

        uint64_t s0;// = e1;
        uint64_t s1;// = e2;

        Z3_get_numeral_uint64(c, e1, &s0);
        Z3_get_numeral_uint64(c, e2, &s1);

        /*std::cout << m << std::endl;

        std::cout << d0 << std::endl;
        std::cout << d1 << std::endl;

        std::cout << e1 << std::endl;
        std::cout << e2 << std::endl;*/

        std::cout << to_string_hex(s0) << " ";
        std::cout << to_string_hex(s1) << std::endl;

        state0 = s0;
        state1 = s1;

        int snum = 0;

        #define HAUNTY_MALL
        #ifdef HAUNTY_MALL
        double saved_next_double = 0.;

        for(int i=0; i<10000000; i++)
        {
            uint64_t res = xorshift128plus();

            double d = chrome(res);

            ///HAUNTY BREAK
            if(d > 0.99 && i > 64)
            {
                printf("%i num\n", i);
                std::cout << d << std::endl;

                uint64_t next = xorshift128plus();
                double dnext = chrome(next);

                saved_next_double = dnext;

                snum = i;
                break;
            }
        }
        #endif

        #ifdef SEEDS
        std::string write_data = to_string_hex(s0) + " " + to_string_hex(s1);
        #endif // SEEDS

        #ifdef HAUNTY_MALL
        std::string write_data = to_string_max_precision(saved_next_double);
        #endif // HAUNTY_MALL

        sf::Mouse::setPosition({-800, 500});

        //Sleep(1);
        mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 9, GetMessageExtraInfo());
        //Sleep(1);
        mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 9, GetMessageExtraInfo());
        Sleep(120);

        for(int i=0; i<write_data.length(); i++)
        {
            uint32_t sc = MapVirtualKey(VkKeyScan(write_data[i]), MAPVK_VK_TO_VSC);

            keybd_event(VkKeyScan(write_data[i]), sc, 0,0);
            keybd_event(VkKeyScan(write_data[i]), sc, KEYEVENTF_KEYUP,0);
        }

        keybd_event(VK_RETURN, MapVirtualKey(VK_RETURN, MAPVK_VK_TO_VSC), 0, 0);
        keybd_event(VK_RETURN, MapVirtualKey(VK_RETURN, MAPVK_VK_TO_VSC), KEYEVENTF_KEYUP, 0);

        /*uint32_t sc = MapVirtualKey(VkKeyScan(in[i]), MAPVK_VK_TO_VSC);

        keybd_event(VkKeyScan(in[i]), sc, 0,0);
        keybd_event(VkKeyScan(in[i]), sc, KEYEVENTF_KEYUP,0);*/

        std::cout.precision(20);

        std::cout << "dw " << write_data << std::endl;

        OpenClipboard(NULL);

        EmptyClipboard();

        CloseClipboard();

        /*for(int i=0; i<5; i++)
        {
            uint64_t res = xorshift128plus();

            double d = chrome(res);

            //std::cout << d << std::endl;
        }

        for(int i=0; i<0; i++)
        {
            uint64_t res = xorshift128plus();

            double d = chrome(res);

            //bool is_eq = d == check_array[i];

            //std::cout << "ie " << is_eq << " num " << d << std::endl;
        }*/

        /*bool found = false;

        for(int i=0; i<100000000; i++)
        {
            uint64_t res = xorshift128plus();

            double d = chrome(res);

            //std::cout << "n " << d << " s " << predict_array[0] << std::endl;

            if(d == predict_array[0])
            {
                printf("we're good\n");

                found = true;
            }
        }

        if(!found)
        {
            printf("fuck\n");
        }*/

    }
    else
    {
        printf("UNSAT\n");

        //std::cout << s << std::endl;
    }

    //f1 101110001100001100000010111111000000010011000100101
    //f2 101110001100001100000001000000111010101101000010110

    return 0;
}
